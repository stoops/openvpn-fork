/*
 *  OpenVPN -- An application to securely tunnel IP networks
 *             over a single TCP/UDP port, with support for SSL/TLS-based
 *             session authentication and key exchange,
 *             packet encryption, packet authentication, and
 *             packet compression.
 *
 *  Copyright (C) 2002-2025 OpenVPN Inc <sales@openvpn.net>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License version 2
 *  as published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <https://www.gnu.org/licenses/>.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "syshead.h"

#include "memdbg.h"

#include "multi.h"
#include "forward.h"
#include "multi_io.h"

#ifdef HAVE_SYS_INOTIFY_H
#include <sys/inotify.h>
#endif

/*
 * Special tags passed to event.[ch] functions
 */
#define MULTI_IO_SOCKET           ((void *)1)
#define MULTI_IO_TUN              ((void *)2)
#define MULTI_IO_SIG              ((void *)3) /* Only on Windows */
#define MULTI_IO_MANAGEMENT       ((void *)4)
#define MULTI_IO_FILE_CLOSE_WRITE ((void *)5)
#define MULTI_IO_DCO              ((void *)6)

struct ta_iow_flags
{
    unsigned int flags;
    unsigned int ret;
    unsigned int tun;
    unsigned int sock;
};

#ifdef ENABLE_DEBUG
static const char *
pract(int action)
{
    switch (action)
    {
        case TA_UNDEF:
            return "TA_UNDEF";

        case TA_SOCKET_READ:
            return "TA_SOCKET_READ";

        case TA_SOCKET_WRITE:
            return "TA_SOCKET_WRITE";

        case TA_TUN_READ:
            return "TA_TUN_READ";

        case TA_TUN_WRITE:
            return "TA_TUN_WRITE";

        case TA_INITIAL:
            return "TA_INITIAL";

        case TA_TIMEOUT:
            return "TA_TIMEOUT";

        default:
            return "?";
    }
}
#endif /* ENABLE_DEBUG */

static inline struct context *
multi_get_context(struct multi_context *m, struct multi_instance *mi)
{
    if (mi)
    {
        return &mi->context;
    }
    else
    {
        return &m->top;
    }
}

struct multi_io
multi_io_init(const int maxclients)
{
    struct multi_io multi_io;

    ASSERT(maxclients >= 1);

    bzero(&(multi_io), sizeof(struct multi_io));
    multi_io.maxevents = maxclients + BASE_N_EVENTS;
    multi_io.es = event_set_init(&multi_io.maxevents, 0);
    wait_signal(multi_io.es, MULTI_IO_SIG);
    ALLOC_ARRAY(multi_io.esr, struct event_set_return, multi_io.maxevents);
    msg(D_MULTI_LOW, "MULTI IO: MULTI_IO INIT maxclients=%d maxevents=%d", maxclients, multi_io.maxevents);

    return multi_io;
}

void
multi_io_free(struct multi_io *multi_io)
{
    if (multi_io->es)
    {
        for (int x = 0; x < MAX_THREADS; ++x)
        {
            event_free(multi_io[x].es);
            free(multi_io[x].esr);
        }
    }
}

int look_link(struct multi_context *m)
{
    for (int x = 0; x < m->max_clients; ++x)
    {
        struct multi_instance *i = m->instances[x];
        struct context *c = multi_get_context(m, i);
        if (!i) { continue; }
        if (LINK_OUT(c))
        {
            multi_set_pending(m, i);
            return TA_SOCKET_WRITE;
        }
        if (LINK_KEYS(i))
        {
            multi_set_pending(m, i);
            return TA_KEYS;
        }
    }
    return TA_UNDEF;
}

int look_left(struct multi_context *m)
{
    for (int x = 0; x < m->max_clients; ++x)
    {
        struct multi_instance *i = m->instances[x];
        if (!i) { continue; }
        if (LINK_LEFT(i))
        {
            multi_set_pending2(m, i);
            return TA_SOCKET_READ;
        }
    }
    return TA_UNDEF;
}

int
multi_io_wait(struct multi_context *m)
{
    int status;
    struct multi_io *multi_io = &(m->multi_io[THREAD_MAIN]);
    unsigned int *persistent = &multi_io->tun_rwflags;

    for (int i = 0; i < m->top.c1.link_sockets_num; ++i)
    {
        socket_set(m->top.c2.link_sockets[i], multi_io->es, EVENT_READ, &m->top.c2.link_sockets[i]->ev_arg, NULL);
    }

    for (int i = 0; i < m->max_clients; ++i)
    {
        struct multi_instance *mi = m->instances[i];
        if (!mi) { continue; }
        if (proto_is_dgram(mi->context.c2.link_sockets[0]->info.proto))
        {
            socket_set(mi->context.c2.link_sockets[0], multi_io->es, EVENT_READ, &mi->context.c2.link_sockets[0]->ev_arg, NULL);
        }
        else
        {
            socket_set(mi->context.c2.link_sockets[0], multi_io->es, EVENT_READ, &mi->ev_arg, NULL);
        }
    }

    if (has_udp_in_local_list(&m->top.options))
    {
        get_io_flags_udp(&m->top, multi_io, p2mp_iow_flags(m));
    }

    tun_set(m->top.c1.tuntap, multi_io->es, EVENT_READ, MULTI_IO_TUN, persistent);
#if defined(ENABLE_DCO)
    dco_event_set(&m->top.c1.tuntap->dco, multi_io->es, MULTI_IO_DCO);
#endif

#ifdef ENABLE_MANAGEMENT
    if (management)
    {
        management_socket_set(management, multi_io->es, MULTI_IO_MANAGEMENT, &multi_io->management_persist_flags);
    }
#endif

#ifdef ENABLE_ASYNC_PUSH
    /* arm inotify watcher */
    event_ctl(multi_io->es, m->top.c2.inotify_fd, EVENT_READ, MULTI_IO_FILE_CLOSE_WRITE);
#endif

    status = event_wait(multi_io->es, &m->top.c2.timeval, multi_io->esr, multi_io->maxevents);
    update_time();
    multi_io->n_esr = (status > 0) ? status : 0;
    return status;
}

static struct multi_instance *
multi_io_dispatch(struct multi_context *m, struct multi_instance *mi, const int action, const unsigned int add_flags)
{
    const unsigned int mpp_flags = MPP_PRE_SELECT | MPP_RECORD_TOUCH | add_flags;

    dmsg(D_MULTI_DEBUG, "MULTI IO: multi_io_dispatch a=%s mi=" ptr_format, pract(action), (ptr_type)mi);

    if (mi) { mi->post = false; }
    if (m->pending) { m->pending->post = false; }
    if (m->pending2) { m->pending2->post = false; }
    if (m->earliest_wakeup) { m->earliest_wakeup->post = false; }

    switch (action)
    {
        case TA_INST_LENG:
        case TA_TUN_READ:
            threaded_multi_inp_tun(m, mpp_flags);
            break;

        case TA_SOCKET_READ:
            multi_tcp_process_incoming_link(m, mi, mpp_flags);
            break;

        case TA_TIMEOUT:
            multi_process_timeout(m, mpp_flags);
            break;

        case TA_TUN_WRITE:
            multi_process_outgoing_tun(m, mpp_flags);
            break;

        case TA_KEYS:
        case TA_SOCKET_WRITE:
            multi_tcp_process_outgoing_link(m, false, mpp_flags);
            break;

        case TA_INITIAL:
            ASSERT(mi);
            mi->post = true;
            break;

        default:
            msg(M_FATAL, "MULTI IO: multi_io_dispatch, unhandled action=%d", action);
    }

    if (mi)
    {
        set_prefix(mi);
        multi_process_post(m, mi, mpp_flags);
        clear_prefix();
    }
    if (m->pending)
    {
        set_prefix(m->pending);
        multi_process_post(m, m->pending, mpp_flags);
        clear_prefix();
    }
    if (m->pending2)
    {
        set_prefix(m->pending2);
        multi_process_post(m, m->pending2, mpp_flags);
        clear_prefix();
    }
    if (m->earliest_wakeup)
    {
        set_prefix(m->earliest_wakeup);
        multi_process_post(m, m->earliest_wakeup, mpp_flags);
        clear_prefix();
        m->earliest_wakeup = NULL;
    }

    return mi;
}

static int
multi_io_post(struct multi_context *m, struct multi_instance *i, const int action, int t)
{
    struct context *c = multi_get_context(m, NULL);
    int newaction = TA_UNDEF;
    int getaction = TA_UNDEF;

    if ((getaction = look_link(m)) != TA_UNDEF)
    {
        if ((t & THREAD_RTWL) != 0)
        {
            newaction = getaction;
            goto last;
        }
    }
    else if (INST_LENG(m))
    {
        if ((t & THREAD_RTWL) != 0)
        {
            newaction = TA_INST_LENG;
            goto last;
        }
    }

    if (TUN_OUT(c))
    {
        if ((t & THREAD_RLWT) != 0)
        {
            newaction = TA_TUN_WRITE;
            goto last;
        }
    }
    else if ((getaction = look_left(m)) != TA_UNDEF)
    {
        if ((t & THREAD_RLWT) != 0)
        {
            newaction = getaction;
            goto last;
        }
    }

last:
    dmsg(D_MULTI_DEBUG, "MULTI IO: multi_io_post %s -> %s", pract(action), pract(newaction));

    return newaction;
}

void
multi_io_process_io(struct thread_pointer *b, const unsigned int f, int t)
{
    struct multi_context *m = b->p->m[b->i-1];
    struct multi_io *multi_io = &(m->multi_io[t]);
    struct multi_instance *mi;
    int i;
    int getaction;

    for (i = 0; i < multi_io->n_esr; ++i)
    {
        struct event_set_return *e = &multi_io->esr[i];
        struct event_arg *ev_arg = (struct event_arg *)e->arg;

        /* incoming data for instance or listening socket? */
        if (e->arg >= MULTI_N)
        {
            /* react to event on child instance */
            if (ev_arg->type == EVENT_ARG_MULTI_INSTANCE)
            {
                ASSERT(ev_arg->u.mi);
                mi = ev_arg->u.mi;
                if (e->rwflags & EVENT_READ)
                {
                    if ((t & THREAD_RLWT) != 0)
                    {
                        struct context *c = multi_get_context(m, NULL);
                        if (TUN_OUT(c))
                        {
                            multi_io_action(m, NULL, TA_TUN_WRITE, false, f, t);
                        }
                        else if (LINK_SOCK(mi))
                        {
                            multi_set_pending2(m, mi);
                            multi_io_action(m, NULL, TA_SOCKET_READ, false, f, t);
                        }
                        else
                        {
                            multi_close_instance_on_signal(m, mi);
                        }
                    }
                }
            }

            /* new incoming TCP client attempting to connect? */
            if (ev_arg->type == EVENT_ARG_LINK_SOCKET)
            {
                if ((t & THREAD_RTWL) != 0)
                {
                    ASSERT(ev_arg->u.sock);
                    if (!proto_is_dgram(ev_arg->u.sock->info.proto))
                    {
                        socket_reset_listen_persistent(ev_arg->u.sock);
                        mi = multi_create_instance_tcp(b, ev_arg->u.sock);
                        if (mi) { multi_io_action(b->p->p, mi, TA_INITIAL, false, f, t); }
                    }
                    else
                    {
                        multi_process_io_udp(m, ev_arg->u.sock);
                        if (m->pending) { multi_io_action(m, m->pending, TA_INITIAL, false, f, t); }
                        if (m->pending2) { multi_io_action(m, m->pending2, TA_INITIAL, false, f, t); }
                    }
                }
            }
        }
        else
        {
#ifdef ENABLE_MANAGEMENT
                if (e->arg == MULTI_IO_MANAGEMENT)
                {
                    ASSERT(management);
                    management_io(management);
                }
#endif
                /* incoming data on TUN? */
                if (e->arg == MULTI_IO_TUN)
                {
                    if (e->rwflags & EVENT_READ)
                    {
                        if ((t & THREAD_RTWL) != 0)
                        {
                            if ((getaction = look_link(m)) != TA_UNDEF)
                            {
                                multi_io_action(m, NULL, getaction, false, f, t);
                            }
                            else
                            {
                                multi_io_action(m, NULL, TA_TUN_READ, false, f, t);
                            }
                        }
                    }
                }
#if defined(ENABLE_DCO)
                /* incoming data on DCO? */
                if (e->arg == MULTI_IO_DCO)
                {
                    multi_process_incoming_dco(m);
                }
#endif
                /* signal received? */
                if (e->arg == MULTI_IO_SIG)
                {
                    if ((t & THREAD_RTWL) != 0)
                    {
                        get_signal(&m->top.sig->signal_received);
                    }
                }
#ifdef ENABLE_ASYNC_PUSH
                if (e->arg == MULTI_IO_FILE_CLOSE_WRITE)
                {
                    if ((t & THREAD_RTWL) != 0)
                    {
                        multi_process_file_closed(m, MPP_PRE_SELECT | MPP_RECORD_TOUCH | f);
                    }
                }
#endif
        }
        if (IS_SIG(&m->top))
        {
            break;
        }
    }

    /*
     * Process queued mbuf packets destined for TCP socket
     */
    if ((t & THREAD_RTWL) != 0)
    {
        while (!IS_SIG(&m->top) && (mi = mbuf_peek(m->mbuf)) != NULL)
        {
            multi_io_action(m, mi, TA_SOCKET_WRITE, true, f, t);
        }
    }

    if ((t & THREAD_RTWL) != 0)
    {
        if (m->mtio_stat == 3)
        {
            for (int x = 0; x < m->max_clients; ++x)
            {
                struct multi_instance *j = m->instances[x];
                if (!j) { continue; }
                if (j->mtio_stat == 3)
                {
                    multi_context_switch_addr(m, j, true, true);
                    j->mtio_stat = 5;
                }
            }
            m->mtio_stat = 5;
        }
    }
}

void
multi_io_action(struct multi_context *m, struct multi_instance *mi, int action, bool poll, const unsigned int flags, int t)
{
    do
    {
        msg(D_MULTI_DEBUG, "MULTI IO: multi_io_action t=%d a=%s p=%d", t, pract(action), poll);

        if ((t == THREAD_RTWL) && !(action == TA_TIMEOUT || action == TA_INITIAL || action == TA_TUN_READ || action == TA_INST_LENG || action == TA_SOCKET_WRITE || action == TA_KEYS))
        {
            break;
        }

        if ((t == THREAD_RLWT) && !(action == TA_TIMEOUT || action == TA_SOCKET_READ || action == TA_TUN_WRITE))
        {
            break;
        }


        /*
         * Dispatch the action
         */
        multi_io_dispatch(m, mi, action, flags);

        /*
         * Signal received or connection
         * reset by peer?
         */
        if (mi && IS_SIG(&mi->context))
        {
            multi_close_instance_on_signal(m, mi);
            break;
        }
        if (m->pending && IS_SIG(&m->pending->context))
        {
            multi_close_instance_on_signal(m, m->pending);
            break;
        }
        if (m->pending2 && IS_SIG(&m->pending2->context))
        {
            multi_close_instance_on_signal(m, m->pending2);
            break;
        }


        /*
         * If dispatch produced any pending output
         * for a particular instance, point to
         * that instance.
         */
        int retry_undef = 0;
        if (t == THREAD_RTWL)
        {
            if (m->pending)
            {
                mi = m->pending;
            }
        }
        if (t == THREAD_RLWT)
        {
            if (m->pending2)
            {
                mi = m->pending2;
            }
        }
        if (t == THREAD_MAIN)
        {
            if (m->pending)
            {
                mi = m->pending;
            }
            if (m->pending2)
            {
                if (!m->pending)
                {
                    mi = m->pending2;
                }
                else
                {
                    retry_undef = 1;
                }
            }
        }


        /*
         * Based on the effects of the action,
         * such as generating pending output,
         * possibly transition to a new action state.
         */
        action = multi_io_post(m, mi, action, t);
        if ((action == TA_UNDEF) && (retry_undef == 1))
        {
            mi = m->pending2;
            action = multi_io_post(m, mi, action, t);
        }


        poll = true;

    } while (action != TA_UNDEF);
}

void
multi_io_delete_event(struct multi_io *multi_io, event_t event)
{
    if (multi_io && multi_io->es)
    {
        event_del(multi_io->es, event);
    }
}
